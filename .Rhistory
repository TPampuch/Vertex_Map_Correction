#Base12
names = unique(Base12$TreeID)
if(length(names) < ref_num) next
ms = data.frame(X = NA, Y = NA)
for(c in 1:length(names)){
Basems = Base12[which(Base12$TreeID == names[c]),]
ms[c,"X"] = (Basems$X.m.[1] - Basems$X.m.[2])
ms[c,"Y"] = (Basems$Y.m.[1] - Basems$Y.m.[2])
}
means[i,] <- c(mean(ms$X), mean(ms$Y), combos[o])
i = i + 1
}
#means
lms[k,1] = sum(as.numeric(means$X)^2 + as.numeric(means$Y)^2)
lms[k,2] = k
#lms
k = k + 1
if(round(lms[k-2,1],4) <= round(lms[k-1,1],4)){ # compare current ms with the previous iteration,
# if the current is similar to the one before or even higher it didn't help
data$X.m.[which(data$Base == b2C)] = data$X.m.[which(data$Base == b2C)]-msdataC$X # undo what have been done, since the change did not improve anything
data$Y.m.[which(data$Base == b2C)] = data$Y.m.[which(data$Base == b2C)]-msdataC$Y
k = k - 1
death = death + 1 # add one to the counter
}else{death = 1} # every time something was improved the counter is set back to 1
}
if(death >= limit) break # if the counter hits the limit the repeat loop stops
}
overlapsZ <- names(which(table(data$TreeID) > 1))
BasesZ <- max(na.omit(data$Base))
lmsZ <- data.frame(sum = NA, iteration = NA)
# calculate initial mean square
ctrlZ = NA
iZ = 1
meansZ = data.frame(Z = NA, Base_combo = NA)
for(a in 1:BasesZ){ # loop 1 of all Bases
for(b in 1:BasesZ){ # loop 2 of all Bases
if(b == a) next # next iteration if a and b are the same Base
ctrlZ = paste(sort(c(a,b))[1], "&", sort(c(a,b))[2]) # control line to avoid doubling base-pairs
if(ctrlZ %in% meansZ$Base_combo) next # next iteration if the combination was already calculated
adataZ <- data[which(data$TreeID %in% overlaps & data$Base == a),]
bdataZ <- data[which(data$TreeID %in% overlaps & data$Base == b),]
adataZ <- adataZ[which(adataZ$TreeID %in% bdataZ$TreeID),]
bdataZ <- bdataZ[which(bdataZ$TreeID %in% adataZ$TreeID),]
if(nrow(adataZ) < 1 | nrow(bdataZ) < 1) next # skip to next loop iteration if there is no row in a or b
Base12Z <- rbind(adataZ,bdataZ)
namesZ = unique(Base12Z$TreeID)
if(length(namesZ) < ref_num) next # skip to next loop iteration if the number of "reference tree" is below the provided amount (should be at least (default) 2)
msZ = data.frame(Z = NA)
for(c in 1:length(namesZ)){
BasemsZ = Base12Z[which(Base12Z$TreeID == namesZ[c]),]
msZ[c,"Z"] = (BasemsZ$ALTITUDE[1] - BasemsZ$ALTITUDE[2])
}
meansZ[iZ,] <- c(mean(msZ$Z), as.character(paste(sort(c(a,b))[1], "&", sort(c(a,b))[2])))
iZ = iZ + 1
}
}
kZ = 1
lmsZ$sum[kZ] = sum(as.numeric(meansZ$Z)^2)
lmsZ$iteration[kZ] = kZ
#lms$sum[1]
kZ = kZ + 1
combosZ = meansZ$Base_combo # now select possible combos and loop through
deathZ = 1
l=1
b1CZ = as.numeric(strsplit(combosZ[l], split = " ")[[1]][1])
b2CZ = as.numeric(strsplit(combosZ[l], split = " ")[[1]][3])
# merging overlapping points of 2 Bases
adataCZ <- data[which(data$TreeID %in% overlaps & data$Base == b1CZ),]
bdataCZ <- data[which(data$TreeID %in% overlaps & data$Base == b2CZ),]
adataCZ <- adataCZ[which(adataCZ$TreeID %in% bdataCZ$TreeID),]
bdataCZ <- bdataCZ[which(bdataCZ$TreeID %in% adataCZ$TreeID),]
Base12CZ <- rbind(adataCZ,bdataCZ)
Base12CZ
# calc difference for each tree
namesZ = unique(Base12CZ$TreeID)
msCZ = data.frame(Z = NA)
for(a in 1:length(namesZ)){
BasemsCZ = Base12CZ[which(Base12CZ$TreeID == namesZ[a]),]
msCZ[a,"Z"] = (BasemsCZ$ALTITUDE[1] - BasemsCZ$ALTITUDE[2])
}
msdataCZ <- data.frame(Z = mean(msCZ$Z)) # calculate mean offset
data$ALTITUDE[which(data$Base == b2CZ)] = data$ALTITUDE[which(data$Base == b2CZ)]+msdataCZ$Z # correct entire dataset
iZ = 1
for(o in 1:length(combosZ)){
b1Z = as.numeric(strsplit(combosZ[o], split = " ")[[1]][1])
b2Z = as.numeric(strsplit(combosZ[o], split = " ")[[1]][3])
adataZ <- data[which(data$TreeID %in% overlaps & data$Base == b1Z),]
bdataZ <- data[which(data$TreeID %in% overlaps & data$Base == b2Z),]
adataZ <- adataZ[which(adataZ$TreeID %in% bdataZ$TreeID),]
bdataZ <- bdataZ[which(bdataZ$TreeID %in% adataZ$TreeID),]
if(nrow(adataZ) < 1 | nrow(bdataZ) < 1) next # skip to next loop iteration if there is no row in a or b
Base12Z <- rbind(adataZ,bdataZ)
#Base12
namesZ = unique(Base12Z$TreeID)
if(length(namesZ) < ref_num) next
msZ = data.frame(Z = NA)
for(c in 1:length(namesZ)){
BasemsZ = Base12Z[which(Base12Z$TreeID == namesZ[c]),]
msZ[c,"Z"] = (BasemsZ$ALTITUDE[1] - BasemsZ$ALTITUDE[2])
}
meansZ[iZ,] <- c(mean(msZ$Z), combosZ[o])
iZ = iZ + 1
}
#meansZ
lmsZ[kZ,1] = sum(as.numeric(meansZ$Z)^2)
lmsZ[kZ,2] = kZ
#lmsZ
kZ = kZ + 1
l=2
b1CZ = as.numeric(strsplit(combosZ[l], split = " ")[[1]][1])
b2CZ = as.numeric(strsplit(combosZ[l], split = " ")[[1]][3])
# merging overlapping points of 2 Bases
adataCZ <- data[which(data$TreeID %in% overlaps & data$Base == b1CZ),]
bdataCZ <- data[which(data$TreeID %in% overlaps & data$Base == b2CZ),]
adataCZ <- adataCZ[which(adataCZ$TreeID %in% bdataCZ$TreeID),]
bdataCZ <- bdataCZ[which(bdataCZ$TreeID %in% adataCZ$TreeID),]
Base12CZ <- rbind(adataCZ,bdataCZ)
Base12CZ
# calc difference for each tree
namesZ = unique(Base12CZ$TreeID)
msCZ = data.frame(Z = NA)
for(a in 1:length(namesZ)){
BasemsCZ = Base12CZ[which(Base12CZ$TreeID == namesZ[a]),]
msCZ[a,"Z"] = (BasemsCZ$ALTITUDE[1] - BasemsCZ$ALTITUDE[2])
}
msdataCZ <- data.frame(Z = mean(msCZ$Z)) # calculate mean offset
data$ALTITUDE[which(data$Base == b2CZ)] = data$ALTITUDE[which(data$Base == b2CZ)]+msdataCZ$Z # correct entire dataset
iZ = 1
for(o in 1:length(combosZ)){
b1Z = as.numeric(strsplit(combosZ[o], split = " ")[[1]][1])
b2Z = as.numeric(strsplit(combosZ[o], split = " ")[[1]][3])
adataZ <- data[which(data$TreeID %in% overlaps & data$Base == b1Z),]
bdataZ <- data[which(data$TreeID %in% overlaps & data$Base == b2Z),]
adataZ <- adataZ[which(adataZ$TreeID %in% bdataZ$TreeID),]
bdataZ <- bdataZ[which(bdataZ$TreeID %in% adataZ$TreeID),]
if(nrow(adataZ) < 1 | nrow(bdataZ) < 1) next # skip to next loop iteration if there is no row in a or b
Base12Z <- rbind(adataZ,bdataZ)
#Base12
namesZ = unique(Base12Z$TreeID)
if(length(namesZ) < ref_num) next
msZ = data.frame(Z = NA)
for(c in 1:length(namesZ)){
BasemsZ = Base12Z[which(Base12Z$TreeID == namesZ[c]),]
msZ[c,"Z"] = (BasemsZ$ALTITUDE[1] - BasemsZ$ALTITUDE[2])
}
meansZ[iZ,] <- c(mean(msZ$Z), combosZ[o])
iZ = iZ + 1
}
#meansZ
lmsZ[kZ,1] = sum(as.numeric(meansZ$Z)^2)
lmsZ[kZ,2] = kZ
#lmsZ
kZ = kZ + 1
l=3
b1CZ = as.numeric(strsplit(combosZ[l], split = " ")[[1]][1])
b2CZ = as.numeric(strsplit(combosZ[l], split = " ")[[1]][3])
# merging overlapping points of 2 Bases
adataCZ <- data[which(data$TreeID %in% overlaps & data$Base == b1CZ),]
bdataCZ <- data[which(data$TreeID %in% overlaps & data$Base == b2CZ),]
adataCZ <- adataCZ[which(adataCZ$TreeID %in% bdataCZ$TreeID),]
bdataCZ <- bdataCZ[which(bdataCZ$TreeID %in% adataCZ$TreeID),]
Base12CZ <- rbind(adataCZ,bdataCZ)
Base12CZ
# calc difference for each tree
namesZ = unique(Base12CZ$TreeID)
msCZ = data.frame(Z = NA)
for(a in 1:length(namesZ)){
BasemsCZ = Base12CZ[which(Base12CZ$TreeID == namesZ[a]),]
msCZ[a,"Z"] = (BasemsCZ$ALTITUDE[1] - BasemsCZ$ALTITUDE[2])
}
msdataCZ <- data.frame(Z = mean(msCZ$Z)) # calculate mean offset
data$ALTITUDE[which(data$Base == b2CZ)] = data$ALTITUDE[which(data$Base == b2CZ)]+msdataCZ$Z # correct entire dataset
iZ = 1
for(o in 1:length(combosZ)){
b1Z = as.numeric(strsplit(combosZ[o], split = " ")[[1]][1])
b2Z = as.numeric(strsplit(combosZ[o], split = " ")[[1]][3])
adataZ <- data[which(data$TreeID %in% overlaps & data$Base == b1Z),]
bdataZ <- data[which(data$TreeID %in% overlaps & data$Base == b2Z),]
adataZ <- adataZ[which(adataZ$TreeID %in% bdataZ$TreeID),]
bdataZ <- bdataZ[which(bdataZ$TreeID %in% adataZ$TreeID),]
if(nrow(adataZ) < 1 | nrow(bdataZ) < 1) next # skip to next loop iteration if there is no row in a or b
Base12Z <- rbind(adataZ,bdataZ)
#Base12
namesZ = unique(Base12Z$TreeID)
if(length(namesZ) < ref_num) next
msZ = data.frame(Z = NA)
for(c in 1:length(namesZ)){
BasemsZ = Base12Z[which(Base12Z$TreeID == namesZ[c]),]
msZ[c,"Z"] = (BasemsZ$ALTITUDE[1] - BasemsZ$ALTITUDE[2])
}
meansZ[iZ,] <- c(mean(msZ$Z), combosZ[o])
iZ = iZ + 1
}
#meansZ
lmsZ[kZ,1] = sum(as.numeric(meansZ$Z)^2)
lmsZ[kZ,2] = kZ
#lmsZ
kZ = kZ + 1
l=4
b1CZ = as.numeric(strsplit(combosZ[l], split = " ")[[1]][1])
b2CZ = as.numeric(strsplit(combosZ[l], split = " ")[[1]][3])
# merging overlapping points of 2 Bases
adataCZ <- data[which(data$TreeID %in% overlaps & data$Base == b1CZ),]
bdataCZ <- data[which(data$TreeID %in% overlaps & data$Base == b2CZ),]
adataCZ <- adataCZ[which(adataCZ$TreeID %in% bdataCZ$TreeID),]
bdataCZ <- bdataCZ[which(bdataCZ$TreeID %in% adataCZ$TreeID),]
Base12CZ <- rbind(adataCZ,bdataCZ)
Base12CZ
# calc difference for each tree
namesZ = unique(Base12CZ$TreeID)
msCZ = data.frame(Z = NA)
for(a in 1:length(namesZ)){
BasemsCZ = Base12CZ[which(Base12CZ$TreeID == namesZ[a]),]
msCZ[a,"Z"] = (BasemsCZ$ALTITUDE[1] - BasemsCZ$ALTITUDE[2])
}
msdataCZ <- data.frame(Z = mean(msCZ$Z)) # calculate mean offset
data$ALTITUDE[which(data$Base == b2CZ)] = data$ALTITUDE[which(data$Base == b2CZ)]+msdataCZ$Z # correct entire dataset
iZ = 1
for(o in 1:length(combosZ)){
b1Z = as.numeric(strsplit(combosZ[o], split = " ")[[1]][1])
b2Z = as.numeric(strsplit(combosZ[o], split = " ")[[1]][3])
adataZ <- data[which(data$TreeID %in% overlaps & data$Base == b1Z),]
bdataZ <- data[which(data$TreeID %in% overlaps & data$Base == b2Z),]
adataZ <- adataZ[which(adataZ$TreeID %in% bdataZ$TreeID),]
bdataZ <- bdataZ[which(bdataZ$TreeID %in% adataZ$TreeID),]
if(nrow(adataZ) < 1 | nrow(bdataZ) < 1) next # skip to next loop iteration if there is no row in a or b
Base12Z <- rbind(adataZ,bdataZ)
#Base12
namesZ = unique(Base12Z$TreeID)
if(length(namesZ) < ref_num) next
msZ = data.frame(Z = NA)
for(c in 1:length(namesZ)){
BasemsZ = Base12Z[which(Base12Z$TreeID == namesZ[c]),]
msZ[c,"Z"] = (BasemsZ$ALTITUDE[1] - BasemsZ$ALTITUDE[2])
}
meansZ[iZ,] <- c(mean(msZ$Z), combosZ[o])
iZ = iZ + 1
}
#meansZ
lmsZ[kZ,1] = sum(as.numeric(meansZ$Z)^2)
lmsZ[kZ,2] = kZ
#lmsZ
kZ = kZ + 1
l= 5
b1CZ = as.numeric(strsplit(combosZ[l], split = " ")[[1]][1])
b2CZ = as.numeric(strsplit(combosZ[l], split = " ")[[1]][3])
# merging overlapping points of 2 Bases
adataCZ <- data[which(data$TreeID %in% overlaps & data$Base == b1CZ),]
bdataCZ <- data[which(data$TreeID %in% overlaps & data$Base == b2CZ),]
adataCZ <- adataCZ[which(adataCZ$TreeID %in% bdataCZ$TreeID),]
bdataCZ <- bdataCZ[which(bdataCZ$TreeID %in% adataCZ$TreeID),]
Base12CZ <- rbind(adataCZ,bdataCZ)
Base12CZ
# calc difference for each tree
namesZ = unique(Base12CZ$TreeID)
msCZ = data.frame(Z = NA)
for(a in 1:length(namesZ)){
BasemsCZ = Base12CZ[which(Base12CZ$TreeID == namesZ[a]),]
msCZ[a,"Z"] = (BasemsCZ$ALTITUDE[1] - BasemsCZ$ALTITUDE[2])
}
msdataCZ <- data.frame(Z = mean(msCZ$Z)) # calculate mean offset
data$ALTITUDE[which(data$Base == b2CZ)] = data$ALTITUDE[which(data$Base == b2CZ)]+msdataCZ$Z # correct entire dataset
iZ = 1
for(o in 1:length(combosZ)){
b1Z = as.numeric(strsplit(combosZ[o], split = " ")[[1]][1])
b2Z = as.numeric(strsplit(combosZ[o], split = " ")[[1]][3])
adataZ <- data[which(data$TreeID %in% overlaps & data$Base == b1Z),]
bdataZ <- data[which(data$TreeID %in% overlaps & data$Base == b2Z),]
adataZ <- adataZ[which(adataZ$TreeID %in% bdataZ$TreeID),]
bdataZ <- bdataZ[which(bdataZ$TreeID %in% adataZ$TreeID),]
if(nrow(adataZ) < 1 | nrow(bdataZ) < 1) next # skip to next loop iteration if there is no row in a or b
Base12Z <- rbind(adataZ,bdataZ)
#Base12
namesZ = unique(Base12Z$TreeID)
if(length(namesZ) < ref_num) next
msZ = data.frame(Z = NA)
for(c in 1:length(namesZ)){
BasemsZ = Base12Z[which(Base12Z$TreeID == namesZ[c]),]
msZ[c,"Z"] = (BasemsZ$ALTITUDE[1] - BasemsZ$ALTITUDE[2])
}
meansZ[iZ,] <- c(mean(msZ$Z), combosZ[o])
iZ = iZ + 1
}
#meansZ
lmsZ[kZ,1] = sum(as.numeric(meansZ$Z)^2)
lmsZ[kZ,2] = kZ
#lmsZ
kZ = kZ + 1
lmsZ
length(combosZ)
kZ > length(combosZ)+1
source("D:/PhD stuff/R-Space/Map Correction Vertex LaserGeo 360/VMC/R/VMC.R")
dat2 <- VMC(map, Base_ID = "base", plot = T, limit = 50, Tree_ID = "Tree_ID", z_corr = T, Tree_DBH = "DBH_cm", Alt_col = "ALTITUDE")[[1]] # its still returning a list. I'll remove this inconvenience in the next version
fig <- plot_ly(dat2, y = ~X.m., x = ~Y.m., z = ~ALTITUDE, color = ~base)
fig
library(plotly)
fig <- plot_ly(dat2, y = ~X.m., x = ~Y.m., z = ~ALTITUDE, color = ~base)
fig
setwd("D:/PhD stuff/R-Space/Map Correction Vertex LaserGeo 360/VMC/")
devtools::document()
setwd("D:/PhD stuff/R-Space/Map Correction Vertex LaserGeo 360/VMC/")
devtools::document()
dat3 <- read.csv("D:/PhD stuff/0. All-Alaska-Data/data/2018/maps/BT_mapRAW.csv")
dat3 <- read.csv("D:/PhD stuff/0. All-Alaska-Data/data/2018/maps/BT_mapRAW.csv", sep = ";")
source("D:/PhD stuff/R-Space/Map Correction Vertex LaserGeo 360/VMC/R/VMC.R")
head(datat)
datat <- read.csv("D:/PhD stuff/0. All-Alaska-Data/data/2018/maps/BT_mapRAW.csv", sep = ";")
head(datat)
dat3 <- VMC(datat, Base_ID = "base", z_corr = T, Tree_ID = "vertexID")
Tree_ID = "vertexID"
z_corr = T
Base_ID = "base"
data = datat
# adjusting colnames based on provided information
if(plot == TRUE){colnames(data)[which(colnames(data) == Tree_DBH)] <- "TreeDBH"}
dat3 <- VMC(datat, Base_ID = "base", z_corr = T, Tree_ID = "vertexID", plot = FALSE)
plot = FALSE
ref_num = 2
limit = 10
# adjusting colnames based on provided information
if(plot == TRUE){colnames(data)[which(colnames(data) == Tree_DBH)] <- "TreeDBH"}
if(z_corr == TRUE){colnames(data)[which(colnames(data) == Alt_col)] <- "ALTITUDE"}
Alt_col = "ALTITUDE"
if(z_corr == TRUE){colnames(data)[which(colnames(data) == Alt_col)] <- "ALTITUDE"}
colnames(data)[which(colnames(data) == Base_ID)] <- "Base"
colnames(data)[which(colnames(data) == Tree_ID)] <- "TreeID"
colnames(data)[which(colnames(data) == X_col)] <- "X.m."
colnames(data)[which(colnames(data) == Y_col)] <- "Y.m."
X_col = "X.m."
Y_col = "Y.m."
colnames(data)[which(colnames(data) == X_col)] <- "X.m."
colnames(data)[which(colnames(data) == Y_col)] <- "Y.m."
if(plot == TRUE){
# create "before" plot of initial data
p1 = ggplot2::ggplot(data, ggplot2::aes(x = Y.m., y = X.m.))+
ggplot2::geom_point(ggplot2::aes(color = as.factor(Base), size = TreeDBH))+
ggplot2::theme_light()+
ggrepel::geom_text_repel(ggplot2::aes(label=TreeID), cex = 2)+
ggplot2::labs(x = "X", y = "Y", title = "Before")
}
overlaps <- names(which(table(data$TreeID) > 1))
Bases <- max(na.omit(data$Base))
lms <- data.frame(sum = NA, iteration = NA)
Bases
# calculate initial mean square
ctrl = NA
i = 1
means = data.frame(X = NA, Y = NA, Base_combo = NA)
ctrl = paste(sort(c(a,b))[1], "&", sort(c(a,b))[2]) # control line to avoid doubling base-pairs
a=1
b=2
ctrl = paste(sort(c(a,b))[1], "&", sort(c(a,b))[2]) # control line to avoid doubling base-pairs
adata <- data[which(data$TreeID %in% overlaps & data$Base == a),]
bdata <- data[which(data$TreeID %in% overlaps & data$Base == b),]
adata
for(a in 1:Bases){ # loop 1 of all Bases
for(b in 1:Bases){ # loop 2 of all Bases
if(b == a) next # next iteration if a and b are the same Base
ctrl = paste(sort(c(a,b))[1], "&", sort(c(a,b))[2]) # control line to avoid doubling base-pairs
if(ctrl %in% means$Base_combo) next # next iteration if the combination was already calculated
adata <- data[which(data$TreeID %in% overlaps & data$Base == a),]
bdata <- data[which(data$TreeID %in% overlaps & data$Base == b),]
adata <- adata[which(adata$TreeID %in% bdata$TreeID),]
bdata <- bdata[which(bdata$TreeID %in% adata$TreeID),]
if(nrow(adata) < 1 | nrow(bdata) < 1) next # skip to next loop iteration if there is no row in a or b
Base12 <- rbind(adata,bdata)
names = unique(Base12$TreeID)
if(length(names) < ref_num) next # skip to next loop iteration if the number of "reference tree" is below the provided amount (should be at least (default) 2)
ms = data.frame(X = NA, Y = NA)
for(c in 1:length(names)){
Basems = Base12[which(Base12$TreeID == names[c]),]
ms[c,"X"] = (Basems$X.m.[1] - Basems$X.m.[2])
ms[c,"Y"] = (Basems$Y.m.[1] - Basems$Y.m.[2])
}
means[i,] <- c(mean(ms$X), mean(ms$Y), as.character(paste(sort(c(a,b))[1], "&", sort(c(a,b))[2])))
i = i + 1
}
}
means
if(plot == TRUE){colnames(data)[which(colnames(data) == Tree_DBH)] <- "TreeDBH"}
if(z_corr == TRUE){colnames(data)[which(colnames(data) == Alt_col)] <- "ALTITUDE"}
colnames(data)[which(colnames(data) == Base_ID)] <- "Base"
colnames(data)[which(colnames(data) == Tree_ID)] <- "TreeID"
colnames(data)[which(colnames(data) == X_col)] <- "X.m."
colnames(data)[which(colnames(data) == Y_col)] <- "Y.m."
overlaps <- names(which(table(data$TreeID) > 1))
overlaps
Bases <- max(na.omit(data$Base))
Bases
lms <- data.frame(sum = NA, iteration = NA)
# calculate initial mean square
ctrl = NA
i = 1
means = data.frame(X = NA, Y = NA, Base_combo = NA)
for(a in 1:Bases){ # loop 1 of all Bases
for(b in 1:Bases){ # loop 2 of all Bases
if(b == a) next # next iteration if a and b are the same Base
ctrl = paste(sort(c(a,b))[1], "&", sort(c(a,b))[2]) # control line to avoid doubling base-pairs
if(ctrl %in% means$Base_combo) next # next iteration if the combination was already calculated
adata <- data[which(data$TreeID %in% overlaps & data$Base == a),]
bdata <- data[which(data$TreeID %in% overlaps & data$Base == b),]
adata <- adata[which(adata$TreeID %in% bdata$TreeID),]
bdata <- bdata[which(bdata$TreeID %in% adata$TreeID),]
if(nrow(adata) < 1 | nrow(bdata) < 1) next # skip to next loop iteration if there is no row in a or b
Base12 <- rbind(adata,bdata)
names = unique(Base12$TreeID)
if(length(names) < ref_num) next # skip to next loop iteration if the number of "reference tree" is below the provided amount (should be at least (default) 2)
ms = data.frame(X = NA, Y = NA)
for(c in 1:length(names)){
Basems = Base12[which(Base12$TreeID == names[c]),]
ms[c,"X"] = (Basems$X.m.[1] - Basems$X.m.[2])
ms[c,"Y"] = (Basems$Y.m.[1] - Basems$Y.m.[2])
}
means[i,] <- c(mean(ms$X), mean(ms$Y), as.character(paste(sort(c(a,b))[1], "&", sort(c(a,b))[2])))
i = i + 1
}
}
k = 1
lms$sum[k] = sum(as.numeric(means$X)^2 + as.numeric(means$Y)^2)
lms$iteration[k] = k
#lms$sum[1]
k = k + 1
combos = means$Base_combo # now select possible combos and loop through
death = 1
combos
ctrl
adata <- data[which(data$TreeID %in% overlaps & data$Base == a),]
dat3 <- VMC(datat, Base_ID = "base", z_corr = T, Tree_ID = "newID", plot = FALSE)
ggplot2::ggplot(dat3, ggplot2::aes(x = Y.m., y = X.m.))+ # just a nice way to plot the data into a map
ggplot2::geom_point(ggplot2::aes(color = as.factor(base), size = DBH_cm))+
ggplot2::theme_light()+
ggrepel::geom_text_repel(ggplot2::aes(label=Tree_ID), cex = 2)+
ggplot2::labs(x = "X", y = "Y", title = "tidy map")
library(ggplot2) # ggplot and
library(ggrepel) # ggrepel are only used for plotting
head(dat3)
dat3 <- VMC(datat, Base_ID = "base", z_corr = T, Tree_ID = "newID", plot = FALSE)[[1]]
head(dat3)
ggplot2::ggplot(dat3, ggplot2::aes(x = Y.m., y = X.m.))+ # just a nice way to plot the data into a map
ggplot2::geom_point(ggplot2::aes(color = as.factor(base), size = DBH_cm))+
ggplot2::theme_light()+
ggrepel::geom_text_repel(ggplot2::aes(label=newID), cex = 2)+
ggplot2::labs(x = "X", y = "Y", title = "tidy map")
fig <- plot_ly(dat3, y = ~X.m., x = ~Y.m., z = ~ALTITUDE, color = ~base)
fig
?plot_ly
fig <- plot_ly(dat3, y = ~X.m., x = ~Y.m., z = ~ALTITUDE, color = ~base, type = "bar")
fig
fig <- plot_ly(dat3, y = ~X.m., x = ~Y.m., z = ~ALTITUDE, color = ~base, type = "scatter")
fig
fig <- plot_ly(dat3, y = ~X.m., x = ~Y.m., z = ~ALTITUDE, color = ~base, type = "connectgaps")
fig
fig <- plot_ly(dat3, y = ~X.m., x = ~Y.m., z = ~ALTITUDE, color = ~base, type = "heatmap")
fig
fig <- plot_ly(dat3, y = ~X.m., x = ~Y.m., z = ~ALTITUDE, color = ~base, type = "scatter3d")
fig
source("D:/PhD stuff/R-Space/Map Correction Vertex LaserGeo 360/VMC/R/VMC.R")
library(akima)
install.packages("akima")
s <- interp(dat3$X.m.,dat3$Y.m.,dat3$ALTITUDE)
library(akima)
s <- interp(dat3$X.m.,dat3$Y.m.,dat3$ALTITUDE)
dat3$X.m.
x <- na.omit(dat3$Y.m.)
z <- na.omit(dat3$ALTITUDE)
y <- na.omit(dat3$X.m.)
x <- na.omit(dat3$Y.m.)
y <- na.omit(dat3$X.m.)
z <- na.omit(dat3$ALTITUDE)
s <- interp(x,y,z)
s <- interp(x,y,z, duplicate = "mean")
fig <- plot_ly(dat3, y = ~X.m., x = ~Y.m., z = ~ALTITUDE, color = ~base, type = "scatter3d")+
add_surface(s)
fig <- plot_ly(dat3, y = ~X.m., x = ~Y.m., z = ~ALTITUDE, color = ~base, type = "scatter3d")+
add_surface(s$z)
fig <- plot_ly(dat3, y = ~X.m., x = ~Y.m., z = ~ALTITUDE, color = ~base, type = "scatter3d")
image.plot(s)
install.packages("fields")
fields::image.plot(s)
fig <- plot_ly(dat3, y = s$y, x = s$x, z = s$z, color = ~base, type = "scatter3d")
fig
fig <- plot_ly(s, y = s$y, x = s$x, z = s$z, color = ~base, type = "scatter3d")
fig
fig <- plot_ly(s, y = s$y, x = s$x, z = s$z)
fig
fig <- plot_ly(dat3, y = ~X.m., x = ~Y.m., z = ~ALTITUDE, color = ~base, type = "scatter3d") %>% add_surface()
fig
?add_surface
fig <- plot_ly(dat3, y = ~X.m., x = ~Y.m., z = ~ALTITUDE, color = ~base, type = "scatter3d") %>% add_surface(z = s$z)
fig
fig <- plot_ly(dat3, y = ~X.m., x = ~Y.m., z = ~ALTITUDE, color = ~base, type = "scatter3d") %>% add_surface(z = s$z, x = s$x, y = s$y)
fig
fig <- plot_ly(dat3, y = ~X.m., x = ~Y.m., z = ~ALTITUDE, color = ~base, type = "scatter3d") %>% add_surface(z = s$z, x = s$y, y = s$x)
fig
x <- na.omit(dat3$X.m.)
y <- na.omit(dat3$Y.m.)
z <- na.omit(dat3$ALTITUDE)
s <- interp(x,y,z, duplicate = "mean")
fields::image.plot(s)
fig <- plot_ly(dat3, y = ~X.m., x = ~Y.m., z = ~ALTITUDE, color = ~base, type = "scatter3d") %>% add_surface(z = s$z, x = s$x, y = s$y)
fig
fig <- plot_ly(dat3, y = ~Y.m., x = ~X.m., z = ~ALTITUDE, color = ~base, type = "scatter3d") %>% add_surface(z = s$z, x = s$x, y = s$y)
fig
x <- na.omit(dat3$Y.m.)
y <- na.omit(dat3$X.m.)
z <- na.omit(dat3$ALTITUDE)
s <- interp(x,y,z, duplicate = "mean")
s <- interp(x = x, y = y, z = z, duplicate = "mean")
setwd("D:/PhD stuff/R-Space/Map Correction Vertex LaserGeo 360/VMC/")
devtools::document()
setwd("D:/PhD stuff/R-Space/Map Correction Vertex LaserGeo 360/VMC/")
devtools::document()
